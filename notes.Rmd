---
title: "SAS Course"
author: "Douwe Horsthuis"
date: "`r Sys.Date()`"
output: github_document
editor_options: 
  markdown: 
    wrap: 72
---


# SAS steps

A SAS script is created by coding several "steps". SAS has 2 types of
steps data steps or procedure steps. You can recognize what a step is
about by looking at the first word of the code snipped. It either starts
with DATA or PROC, but there are are also global statements that can
happen outside of these steps.\
Steps either end with a run statement, most of the time, or a quit
statement (some of the time).

## Data step

Data steps usually read data from an input source, processes it and
creates a SAS table. It might also filter rows, create new columns or
join tables or do other data manipulation.

## Procedure (Proc) step

A proc step processes a SAS table in a specific and predefined way. This
can be outputting a certain graph or doing statistics.

## Global statements

These statements are things like "Title, Options, Libname etc. They
exist outside of the steps, and do not need a run statement after them.

# Simple Syntax error solving steps

When certain key words (such as DATA or var) are typed, SAS
automatically changes their color and sometimes makes them bold. If this
does not happen there is likely to be an error directly before it. If
you run code you should always first check the Log from top to bottom,
if there are errors, these will be noted there. It will tell you what
SAS thought was wrong and how it handled it.

# Column lengths

Oddly enough, the column length will dictate how long the variable can
be. So you have to predefined how many characters can be used. For
example, if the length is 2, "East Coast" will become "EA".

# Missing values

Missing numerical values are represented as a period. They are treated
as the smallest possible number. Missing character values are a
represented as a \*.

# Libraries

When loading data, you can hardcore a file path to your data. Or you can
use a Library to make this quicker and easier to change. You do this by
using `LIBNAME libref enging "path";` This will create a way for SAS to
find your data.

# Working with excel data

When loading data that has column names that wouldn't work for SAS. You
can use `OPTONS VALIDVARNAME=V7;` to make them valid. Things like spaces
or special characters become underscores and every column name is
shortened if needed to be shorter than 32 chars.\
Another important thing is to clear your library reference at the end of
your program. This will otherwise create a lock for other people.
`LIBNAME libref CLEAR;` Using `Sheet=Sheet_name` will allow you to load
anything else than the first excel sheet.

# Importing unstructured data

To import unstructured data, without a wizard, you can use

``` sas
PROC IMPORT DATAFILE="path/filename" DBMS=filetype
  OUT=output-table-name;
RUN;
```

SAS will use the first 20 rows to figure out the column attributes etc.
You can change this by using `GUESSINGROWS=n|MAX;` Either set N to how
much you want it to be or use MAX for all rows.

``` sas
*Complete the PROC IMPORT step;
PROC import datafile="filpath/filename.csv" dbms=CSV
    out=storm_damage_import replace;
Run;
  
*Complte the PROC OCNTENTS step;
PROC contents data=storm_damage_import;
run;
```

# Procudures

Print: creates a listing of all rows and columns of the data.\
Means: simple summary statistics (N Mean Std dev Min Max).\
Univariate: more detailed summary statistics.\
Freq: creates a frequency table for each column in the input table

# WHERE statement

Works like this:

``` sas
Proc procudure-name;
  WHERE expression;
RUN;
```

For dates you follow the "SAS date constant". For example:
*"ddmmmmyyyy"d;*

## Missing values and WHERE statements

IF you do a WHERE statement where you say that a variable needs to be
smaller then x. Make sure to include 0\< before, or all the missing
values will be included. Example: `0<MinPressure<920`

If you are specifically looking for missing values you can use
`where Type=. or Type=" ";` Or you can use the special option of "is
missing", "is NOT MISSING" or "is NULL";\
`WHERE col-name IS MISSING;`\
`WHERE col-name IS NOT MISSING;` `WHERE col-name IS NULL;`\
`WHERE AGE IS MISSING;`\
`WHERE col-name IS null;`

## Wildcards for WHERE statements

\% is a wildcard for any number of characters.\
\_ is a wildcard for a single character

for
[[example:\\\\](example:){.uri}](%5Bexample:%5D(example:)%7B.uri%7D){.uri}
`Where city like "New%"; Give new york new delly etc.`Where city like
"sant\_ %"\`\
Gives you for example Santa Clara or Santo Domingo

# Format statements

## Decimals

You can use format statements to edit the included data. For example
using: `format Height 4.1 Weight 3.;` Gives your for height 1 decimal
number and whole numbers for Weight.

## Date

You can turn sas (a number that starts at jan-1-1960) dates into a
positive or negative number. This can be formatted using:

+--------------+--------------+--------------+-----------+------------+
| **To do this | **Use this   | **List**     | **Input** | **Result** |
| \...**       | \...**       |              |           |            |
+==============+==============+==============+===========+============+
| Write SAS    | Date formats | DATE**w.**   | 14686     | 17MAR00    |
| date values  |              |              |           |            |
| in           |              |              |           |            |
| recognizable |              |              |           |            |
| forms        |              |              |           |            |
+--------------+--------------+--------------+-----------+------------+
| \            | \            | DATE9.       | 14686     | 17MAR2000a |
|              |              |              |           |            |
|              |              |              |           | \          |
+--------------+--------------+--------------+-----------+------------+
| \            | \            | DAY**w.**    | 14686     | 17         |
+--------------+--------------+--------------+-----------+------------+
| \            | \            | DDMMYY**w.** | 14686     | 17/03/00   |
+--------------+--------------+--------------+-----------+------------+
| \            | \            | DDMMYY10.    | 14686     | 17/03/2000 |
+--------------+--------------+--------------+-----------+------------+

For all options [see this
website](https://v8doc.sas.com/sashtml/lrcon/zenid-63.htm)

# combining statement

You can combine multiple statements using `and` or `or`.
`WHERE Type="SUV" or Type="truck" or Type="wagon;`

However, it's better to use `in`;\
`Where col-name IN (value1<...,value-n>);`\
`Where col-name NOT IN (value1<...,value-n>);`\
`Where Type IN ("SUV", "Truck", "Wagon");`

# Macro variables

Macro variable are variables you can create that allow you to group
names, so you only have to change it in one place. For example if you
want to change the `Type="Wagon"` to `Type="SUV"`:

``` sas
proc print data=sashelp.cars;
  where Type="Wagon";
  var Type make Model MSRP;
Run;
proc means data=sashelp.cars;
  where Type="Wagon";
  var MSRP MPG_Highway;
Run;
proc freq data=sashelp.cars;
  where Type="Wagon";
  tables Origin Make;
Run;
```

You would have to change 3 things. If you instead start with
`%let VaribleName=Columnname` you would only have to change the
Columname (Wagon) to SUV.

``` sas
%let CarType=Wagon;
proc print data=sashelp.cars;
  where Type="&CarType";
  var Type make Model MSRP;
Run;
proc means data=sashelp.cars;
  where Type="&CarType";
  var MSRP MPG_Highway;
Run;
proc freq data=sashelp.cars;
  where Type="&CarType";
  tables Origin Make;
Run;
```

There are no quotation marks. However, if you reference the macro
variable you need to put quotation marks if you would have normally and
they always need to be double quotation marks.

# Formating your output

In the case of Money or dates it might be usefull or nececery to look at
a formatted output because raw data does not make sense. In this case
you can use the `FORMAT col-name(s) format;` function. The format needs
the following input:\
\<\$\>format-name<w>.<d> where \$= a characther\
w= the width .=required delimiter\
d=number of decimal places\
For example: `format height weight 3.` which should give you 3 numbers
for both of them.

![Common formats](images/common_formats.png)

# Sorting values

For this you can use the `by` function. It will sort the data ascendancy
based on the variable that follows `by`.

# Deleting duplicates

For this you can use the `NoDUPKEY<DUPOUT=output-table>;` If you add the
`DUPOUT=output-table` you will end up also with a table with all the
duplicates.\
If you add `By_all_;` It will only delete duplicates where all columns
are the same. If it depends on sepecific columns you instead say
`by col-name(s);`

# Creating new Columns

Creating new columns is easy. You can simply add `new-colum=expression`
under the `set` part. Like this:

``` sas
DATA output-table;
  SET input-table;
  new-column=expression
RUN;
```

This would be a real example:

``` sas
data cars_new;
  set sashelp.cars  
  where Origin ne "USA";  
  Profit = MSRP-Invoice; *new column MSRP minus Invoice    
  Source ="Non-US Cars"; *new column add this text for each row    
  format Profit dollar10.;  
  keep Make Model MSRP Invoice Profit Source; *need to include the new columns also  
Run;
```

**If you use the same name as an existing column, you will overwrite
that one**

### New Column lenght
Your new column will use the length of the first variable you assign to it. To be on the safe side you can choose to define this yourself. If you add this before the first assignment:  
`length new-column-name $ length`

## Using Functions

### Common Numeric Functions

+-----------------------+----------------------------------------------+
| **Common Numeric      | **What it Does**                             |
| Functions**           |                                              |
+:======================+:=============================================+
| SUM (*num1*, *num2*,  | Returns the sum of nonmissing arguments.     |
| \...)                 |                                              |
+-----------------------+----------------------------------------------+
| MEAN (*num1*, *num2*, | Returns the arithmetic mean (average) of     |
| \...)                 | nonmissing arguments.                        |
+-----------------------+----------------------------------------------+
| MEDIAN (*num1*,       | Returns the median value of nonmissing       |
| *num2*, \...)         | arguments.                                   |
+-----------------------+----------------------------------------------+
| RANGE (*num1*,        | Returns the range of the nonmissing values.  |
| *num2*, \...)         |                                              |
+-----------------------+----------------------------------------------+
| MIN (*num1*, *num2*,  | Returns the smallest nonmissing value from a |
| \...)                 | list of arguments.                           |
+-----------------------+----------------------------------------------+
| MAX (*num1*, *num2*,  | Returns the largest value from a list of     |
| \...)                 | arguments.                                   |
+-----------------------+----------------------------------------------+
| N (*num1*, *num2*,    | Returns the number of nonmissing numeric     |
| \...)                 | values.                                      |
+-----------------------+----------------------------------------------+
| NMISS (*num1*,        | Returns the number of null and SAS missing   |
| *num2*, \...)         | numeric values.                              |
+-----------------------+----------------------------------------------+

#### Character functions

+----------------------+----------------------------------------------+
| **Character          | **What it Does**                             |
| Function**           |                                              |
+:=====================+:=============================================+
| UPCASE (*char*)      | Changes letters in a character string to     |
| LOWCASE(*char*)      | uppercase or lowercase                       |
+----------------------+----------------------------------------------+
| PROPCASE             | Changes the first letter of each word to     |
| (*cha                | uppercase and other letters to lowercase     |
| r*,\<*delimiters*\>) |                                              |
+----------------------+----------------------------------------------+
| CATS (*char1*,       | Concatenates character strings and removes   |
| *char2*, \...)       | leading and trailing blanks from each        |
|                      | argument                                     |
+----------------------+----------------------------------------------+
| SUBSTR (*char*,      | Returns a substring from a character string  |
| *position*,          |                                              |
| \<*length*\>)        |                                              |
+----------------------+----------------------------------------------+

### Extracting dates  

| **Date Function**    | **What it Does**                                                                  |
|:---------------------|:----------------------------------------------------------------------------------|
| MONTH (*SAS-date*)   |  Returns a number from 1 through 12 that represents the month                     |
| YEAR (*SAS-date*)    |  Returns the four-digit year                                                      |
| DAY (*SAS-date*)     |  Returns a number from 1 through 31 that represents the day of the month          |
| WEEKDAY (*SAS-date*) |  Returns a number from 1 through 7 that represents the day of the week (Sunday=1) |
| QTR (*SAS-date*)     |  Returns a number from 1 through 4 that represents the quarter                    |

### Creating dates

| **Date Function**                     | **What it Does**                                                                                                           |
|:--------------------------------------|:---------------------------------------------------------------------------------------------------------------------------|
| TODAY ()                              | Returns the current date as a numeric SAS date value (no argument is required because the function reads the system clock) |
| MDY (*month*, *day*, *year*)          |  Returns a SAS date value from numeric month, day, and year values                                                         |
| YRDIF (*startdate*, *enddate*, 'AGE') |  Calculates a precise age between two dates                                                                                |

### Date diff

When a new column needs to use a start and end date to create a
difference you can do so using
`actual=datdif(sdate, edate, 'act/act');`. The last part `act/act` is
explained
[here](https://documentation.sas.com/doc/en/vdmmlcdc/8.1/lefunctionsref/p1gz65986b9jqin19zk9xqbi7ns3.htm#n1hy1l7p4g12g5n125ag7u34tsco).

# Conditional Processing with IF-THEN/ELSE  
SAS can use IF-THEN/ELSE statements. It's pretty much like any other language. You can add `If statements` followed by a `then statment` and follow these up with `else if` - `then` or `else`. You can inlclude `and` / `or` statements. 

## Processing Multiple Statements with IF-THEN/DO
If you want multiples things to happen after a `if-then` statement, you can use the `THEN DO` statement instead of only `then`. This allows you to add multiple steps. 

See this example:  
```SAS
data under40 over 40;
  set sashelp.cars;
  keep Make Model msrp cost_group;
  if MSRP<2000 then do;
    Cost_Group=1;
    Output under40;
  end;
  else if MSRP<4000 then do;
    Cost_Group=2;
    output under40;
  end;
  else do;
    Cost_Group=3;
    ouput over 40;
  end;
Run;
  